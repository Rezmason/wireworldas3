package net.rezmason.text {		import flash.desktop.Clipboard;	import flash.desktop.ClipboardFormats;	import flash.display.CapsStyle;	import flash.display.DisplayObject;	import flash.display.JointStyle;	import flash.display.LineScaleMode;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.FocusEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.text.TextFormatAlign;	import flash.text.engine.ElementFormat;	import flash.text.engine.FontDescription;	import flash.text.engine.TextBlock;	import flash.text.engine.TextElement;	import flash.text.engine.TextLine;	import flash.ui.Keyboard;	import flash.ui.Mouse;	import flash.ui.MouseCursor;	import flash.utils.Timer;		public class Tyro extends Sprite {				private static const WEIRDOS:RegExp = /[ -\/:-@\[-`\{-~]/;		private static const NON_SPACE:RegExp = /[^ ]/;				private static const CHANGE_EVENT:Event = new Event(Event.CHANGE);		private static const COMPLETE_EVENT:Event = new Event(Event.COMPLETE);				private var blankSelection:Boolean = false;		private var empty:Boolean;		//private var history:Object = {};		private var _horizontalMargin:int = 4, _verticalMargin:int = 4;		private var selecting:Boolean = false;		private var wordMode:Boolean = false;		private var shiftKeyDown:Boolean = false;		private var anchorIndex:int = -1, activeIndex:int = -1;		private var indicesUnspecified:Boolean = true;		private var oldBeginIndex:int, oldEndIndex:int;		private var _text:String, _txet:String;		private var defaultFormat:ElementFormat = new ElementFormat(new FontDescription("_sans"), 12, 0x0);		private var _format:ElementFormat;		private var block:TextBlock = new TextBlock(), line:TextLine;		private var mouseUpCount:int = 0, mouseUpTimer:Timer = new Timer(350, 1);		private var base:Sprite = new Sprite(), container:Sprite = new Sprite();		private var defaultCursor:Shape = new Shape();		private var _cursor:DisplayObject = defaultCursor, cursorTimer:Timer = new Timer(500);		private var slideAmount:Number = 0, slideTimer:Timer = new Timer(10);		private var _scrollRect:Rectangle, defaultScrollRect:Rectangle;		private var focusedIn:Boolean = false;		private var showingDefaultText:Boolean = false;				private var _width:Number;		private var _align:String = TextFormatAlign.LEFT;		private var _selectionColor:int = 0x0000FF, _selectionAlpha:Number = 0.25;		private var _border:Number = 0, _borderColor:int = 0x0, _borderAlpha:Number = 1;		private var _background:Boolean = true, _backgroundColor:int = 0xFFFFFF, _backgroundAlpha:Number = 1;		private var _maxChars:int = 0, _charSet:String = "", charLimiter:RegExp;		private var _selectable:Boolean = true, _editable:Boolean = false;		private var _delayedRefresh:Boolean = false, waiting:Boolean = false;		private var _defaultColor:int = 0x808080, _defaultText:String = "";				public function Tyro(__text:String = null, __format:ElementFormat = null, __width:Number = NaN):void {						_text = __text || "";			_txet = _text.split("").reverse().join("");			_format = __format || defaultFormat.clone();			_width = isNaN(__width) ? 100 : Math.max(0, __width);						focusRect = false;			container.mouseChildren = container.mouseEnabled = false;			_cursor.visible = false;			cursorTimer.addEventListener(TimerEvent.TIMER, flashCursor);			slideTimer.addEventListener(TimerEvent.TIMER, updateSliding);						addEventListener(MouseEvent.MOUSE_DOWN, beginSelect);			addEventListener(MouseEvent.ROLL_OVER, updateCursor);			addEventListener(MouseEvent.ROLL_OUT, updateCursor);			addEventListener(FocusEvent.FOCUS_IN, focusIn);			addEventListener(FocusEvent.FOCUS_OUT, focusOut);			addEventListener(KeyboardEvent.KEY_DOWN, handleKeyboard);			addEventListener(Event.SELECT_ALL, handleClipboard);			addEventListener(Event.CUT, handleClipboard);			addEventListener(Event.COPY, handleClipboard);			addEventListener(Event.PASTE, handleClipboard);						defaultCursor.graphics.lineStyle(0, 0x0);			defaultCursor.graphics.lineTo(0, 1);						addChild(base);			addChild(container);			container.addChild(_cursor);						redrawTextLine();		}				public function get delayedRefresh():Boolean { return _delayedRefresh; }		public function set delayedRefresh(value:Boolean):void {			_delayedRefresh = value;			if (!_delayedRefresh && waiting) refresh();		}				public function get align():String { return _align; }		public function set align(value:String):void {			if (_align != value) {				_align = value;				maybeRefresh();			}		}				override public function set width(value:Number):void {			if (_width != value) {				_width = value;				maybeRefresh();			}		}				override public function set height(value:Number):void {};				public function get horizontalMargin():Number { return _horizontalMargin; }		public function set horizontalMargin(value:Number):void {			if (_horizontalMargin != value) {				_horizontalMargin = value;				maybeRefresh();			}		}				public function get verticalMargin():Number { return _verticalMargin; }		public function set verticalMargin(value:Number):void {			if (_verticalMargin != value) {				_verticalMargin = value;				maybeRefresh();			}		}				public function get cursor():DisplayObject { return _cursor; }		public function set cursor(value:DisplayObject):void {			if (_cursor) container.removeChild(_cursor);			_cursor = value || defaultCursor;			container.addChild(_cursor);			_cursor.transform.matrix = new Matrix();			var cursorRect:Rectangle = _cursor.getBounds(_cursor);			_cursor.scaleX = _cursor.scaleY = height / cursorRect.bottom;		}				public function get selectionColor():int { return _selectionColor; }		public function set selectionColor(value:int):void {			if (_selectionColor != value) {				_selectionColor = value;				maybeRefresh();			}		}				public function get selectionAlpha():Number { return _selectionAlpha; }		public function set selectionAlpha(value:Number):void {			if (_selectionAlpha != value) {				_selectionAlpha = value;				maybeRefresh();			}		}				public function get defaultText():String { return _defaultText; }		public function set defaultText(value:String):void {			if (_defaultText != value) {				_defaultText = value;				maybeRefresh();			}		}				public function get defaultColor():int { return _defaultColor; }		public function set defaultColor(value:int):void {			if (_defaultColor != value) {				_defaultColor = value;				maybeRefresh();			}		}				public function get border():Number { return _border; }		public function set border(value:Number):void {			if (value < 0) value = NaN;			if (_border != value) {				_border = value;				maybeRefresh();			}		}				public function get borderColor():int { return _borderColor; }		public function set borderColor(value:int):void {			if (_borderColor != value) {				_borderColor = value;				maybeRefresh();			}		}				public function get borderAlpha():Number { return _borderAlpha; }		public function set borderAlpha(value:Number):void {			if (_borderAlpha != value) {				_borderAlpha = value;				maybeRefresh();			}		}				public function get background():Boolean { return _background; }		public function set background(value:Boolean):void {			if (_background != value) {				_background = value;				maybeRefresh();			}		}				public function get backgroundColor():int { return _backgroundColor; }		public function set backgroundColor(value:int):void {			if (_backgroundColor != value) {				_backgroundColor = value;				maybeRefresh();			}		}				public function get backgroundAlpha():Number { return _backgroundAlpha; }		public function set backgroundAlpha(value:Number):void {			if (_backgroundAlpha != value) {				_backgroundAlpha = value;				maybeRefresh();			}		}				public function get text():String { return _text; }		public function set text(value:String):void {			if (_text != value) {				deselect();				_text = value;				_txet = _text.split("").reverse().join("");				maybeRefresh();			}		}				public function get maxChars():int { return _maxChars; }		public function set maxChars(value:int):void {			_maxChars = Math.max(0, value);			text = _text.substring(0, _maxChars);		}				public function get charSet():String { return _charSet; }		public function set charSet(value:String):void {			_charSet = value || "";			charLimiter = new RegExp("[^" + _charSet + "]", "g");			text = _text.replace(charLimiter, "");		}				public function get selectable():Boolean { return _selectable; }		public function set selectable(value:Boolean):void {			_selectable = value;			if (base.getRect(base).contains(mouseX, mouseY)) Mouse.cursor = _selectable ? MouseCursor.IBEAM : MouseCursor.AUTO;			if (!_selectable) {				deselect();				if (_editable) editable = false;			}		}				public function get editable():Boolean { return _editable; }		public function set editable(value:Boolean):void {			_editable = value;			if (!_editable) {				hideCursor();			} else if (!_selectable) {				selectable = true;			}		}				public function get format():ElementFormat {			return _format.clone();		}				public function set format(value:ElementFormat):void {			_format = (value || defaultFormat).clone();			maybeRefresh();		}				public function get selectedText():String {			var leftIndex:int  = Math.min(anchorIndex, activeIndex);			var rightIndex:int = Math.max(anchorIndex, activeIndex);			return _text.substring(leftIndex, rightIndex);		}				public function setSelection(start:int, end:int):void {			anchorIndex = Math.max(0, Math.min(_text.length, start));			activeIndex = Math.max(0, Math.min(_text.length, end));			maybeRefresh();			hideCursor();			if (activeIndex == anchorIndex) showCursor();		}				////////////////////////////////////////////////////////////////////////////////////////					private function maybeRefresh():void {			if (_delayedRefresh) {				if (!waiting) {					waiting = true;					addEventListener(Event.ENTER_FRAME, refresh);				}			} else {				refresh();			}		}				private function refresh(event:Event = null):void {			if (waiting) {				removeEventListener(Event.ENTER_FRAME, refresh);				waiting = false;			}			redrawTextLine();		}					private function redrawTextLine():void {			container.scrollRect = null;						if (line) {				container.removeChild(line);				block.releaseLines(line, line);			}									empty = _text.length == 0;			showingDefaultText = (empty && _defaultText.length);						if ((!focusedIn || !_editable) && showingDefaultText) {				block.content = new TextElement(_defaultText, _format);				line = block.createTextLine();					var ct:ColorTransform = new ColorTransform();				ct.color = _defaultColor;				line.transform.colorTransform = ct;			} else {				block.content = new TextElement(_text || " ", _format);				line = block.createTextLine();			}						redrawBase();						line.y = -line.getBounds(line).top + line.descent;			container.addChild(line);			container.x = _horizontalMargin;			container.y = _verticalMargin;						redrawSelection();						if (line.width < _scrollRect.width) {				_scrollRect.x = defaultScrollRect.x;				if (_align == TextFormatAlign.RIGHT) _scrollRect.x -= defaultScrollRect.width - line.width;				container.scrollRect = _scrollRect;			}		}				private function redrawBase():void {			base.graphics.clear();			if (!isNaN(_border)) {				base.graphics.lineStyle(_border * 2, _borderColor, _borderAlpha, false, LineScaleMode.NONE, CapsStyle.NONE, JointStyle.MITER);				base.graphics.drawRect(0, 0, _width, line.textHeight + line.descent * 2 + 2 * _verticalMargin);				base.graphics.lineStyle();			}						if (_background) {				base.graphics.beginFill(_backgroundColor, _backgroundAlpha);			} else {				base.graphics.beginFill(0x0, 0);			}						base.graphics.drawRect(0, 0, _width, line.textHeight + line.descent * 2 + 2 * _verticalMargin);			base.graphics.endFill();							var cursorRect:Rectangle = _cursor.getBounds(_cursor);			_cursor.scaleX = _cursor.scaleY = height / cursorRect.bottom;						_scrollRect = base.getRect(base);			_scrollRect.right -= 2 * _horizontalMargin;			_scrollRect.bottom -= 2 * _verticalMargin;			defaultScrollRect = _scrollRect.clone();			container.scrollRect = _scrollRect;		}				private function beginSelect(event:MouseEvent):void {			if (!_selectable) return;						focusedIn = true;			stage.focus = this;						shiftKeyDown = event.shiftKey;			if (!selecting) {				stage.addEventListener(MouseEvent.MOUSE_UP, endSelect);				stage.addEventListener(MouseEvent.MOUSE_MOVE, updateSelect);				updateSelect();			}			selecting = true;			hideCursor();			if (!shiftKeyDown) anchorIndex = activeIndex = getCursorIndexUnderMouse();			if (empty) anchorIndex = activeIndex = 0;			redrawTextLine();			if (empty) showCursor();			if (!mouseUpTimer.running) {				mouseUpTimer.start();				mouseUpCount = 0;			}		}				private function updateSelect(event:MouseEvent = null):void {			if (!selecting) return;			if (empty) {				anchorIndex = activeIndex = 0;				return;			}			if (shiftKeyDown && wordMode) {				var oldAnchorIndex:int = anchorIndex;				var oldActiveIndex:int = activeIndex;				var word:Object = getWordUnderCursor(getCursorIndexUnderMouse(), true);				if (!word.isWhitespace) {					anchorIndex = Math.min(oldAnchorIndex, oldActiveIndex, word.start, word.end);					activeIndex = Math.max(oldAnchorIndex, oldActiveIndex, word.start, word.end);				}			} else {				activeIndex = getCursorIndexUnderMouse();			}						if (mouseX < 0 ) {				slideAmount = mouseX * 0.08;				beginSliding();			} else if (mouseX > width) {				slideAmount = (mouseX - width) * 0.1;				beginSliding();			} else {				endSliding();			}						redrawSelection();		}				private function endSelect(event:MouseEvent):void {			updateSelect();			shiftKeyDown = false;			endSliding();			if (selecting) {				stage.removeEventListener(MouseEvent.MOUSE_UP, endSelect);				stage.removeEventListener(MouseEvent.MOUSE_MOVE, updateSelect);			}			selecting = false;			indicesUnspecified = true;						Mouse.cursor = base.getRect(base).contains(mouseX, mouseY) ? MouseCursor.IBEAM : MouseCursor.AUTO;						showCursor();						if (mouseUpTimer.running) {				mouseUpCount++;				if (mouseUpCount == 2) {					mouseUpTimer.reset();					var word:Object = getWordUnderCursor(getCursorIndexUnderMouse(), true);					anchorIndex = word.start;					activeIndex = word.end;					redrawSelection();				}			}		}				private function getWordUnderCursor(cursorIndex:int, activate:Boolean):Object {			var returnVal:Object = {start:cursorIndex, end:cursorIndex, isWhitespace:false};			var charIndex:int = cursorIndex;						hideCursor();			wordMode = false;						if (charIndex == _text.length && activate) {				returnVal.start = 0;				returnVal.end = line.atomCount;				return returnVal;			}						var begin:int, end:int;			if (_text.charAt(charIndex) == " ") {				begin = _txet.substring(_text.length - charIndex).search(NON_SPACE);				returnVal.start = (begin == -1) ? 0 : charIndex - begin;				end = _text.substring(charIndex).search(NON_SPACE);				returnVal.end = (end == -1) ? _text.length : end + charIndex;				wordMode = activate;				returnVal.isWhitespace = true;							} else if (_text.charAt(charIndex).search(WEIRDOS) != -1) {				returnVal.end = returnVal.start + 1;			} else {				begin = _txet.substring(_text.length - charIndex).search(WEIRDOS);				returnVal.start = (begin == -1) ? 0 : charIndex - begin;				end = _text.substring(charIndex).search(WEIRDOS);				returnVal.end = (end == -1) ? _text.length : end + charIndex;				wordMode = activate;			}						return returnVal;		}				private function selectAll():void {			anchorIndex = 0;			if (empty) {				if (showingDefaultText) redrawTextLine();				activeIndex = anchorIndex;				showCursor();				return;			}			activeIndex = line.atomCount;			var newX:Number;			if (_align == TextFormatAlign.RIGHT) {				newX = line.width - defaultScrollRect.right + (_cursor.width || 1);			} else {				if (line.width > defaultScrollRect.width) {					newX = line.width - defaultScrollRect.right + _format.fontSize;				} else {					newX = defaultScrollRect.x;				}			}			if (newX != _scrollRect.x) {				_scrollRect.x = newX;				container.scrollRect = _scrollRect;			}			indicesUnspecified = true;			hideCursor();			redrawSelection();		}				private function deselect():void {			anchorIndex = activeIndex = -1;			clearSelection();			hideCursor();		}				private function getCursorIndexUnderMouse():int {			var lineBounds:Rectangle = line.getBounds(stage);			var xPos:Number = Math.max(lineBounds.left + 1, Math.min(lineBounds.right - 1, stage.mouseX));			var atomIndex:Number = line.getAtomIndexAtPoint(xPos, lineBounds.bottom - 1);			if (line.mouseX > line.getAtomCenter(atomIndex)) atomIndex++;			return atomIndex;		}				private function atomToChar(index:int):int {			var candidate:int = index;						var scratch:int;			var patience:int = 5;			var aIAC:int;			while (patience && (scratch = index - (aIAC = line.getAtomIndexAtCharIndex(candidate))) != 0) {				if (aIAC == -1) return _text.length;				else candidate += scratch;				patience--;			}			return candidate;		}				private function beginSliding():void {			slideTimer.start();		}				private function updateSliding(event:Event = null):void {						if (!_selectable) endSliding();						var newX:Number = _scrollRect.x + slideAmount;			newX = Math.max(defaultScrollRect.left, newX)						if (_align == TextFormatAlign.RIGHT) {				newX = Math.min(line.width - defaultScrollRect.right + (_cursor.width || 1), newX);			} else {				newX = Math.min(line.width - defaultScrollRect.right + _format.fontSize, newX);			}						if (newX != _scrollRect.x) {				_scrollRect.x = newX;				container.scrollRect = _scrollRect;				updateSelect();			}		}				private function endSliding():void {			slideTimer.stop();		}				private function clearSelection():void {			container.graphics.clear();			blankSelection = true;		}				private function redrawSelection():void {						var beginIndex:int = Math.min(anchorIndex, activeIndex) - 1;			var endIndex:int = Math.max(anchorIndex, activeIndex) - 1;						if (!blankSelection && beginIndex == oldBeginIndex && endIndex == oldEndIndex) return;			blankSelection = false;			oldBeginIndex = beginIndex, oldEndIndex = endIndex;						var beginX:Number = beginIndex < 0 ? line.getAtomBounds(0).left : line.getAtomBounds(beginIndex).right;			var endX:Number   = endIndex   < 0 ? line.getAtomBounds(0).left : line.getAtomBounds(endIndex  ).right;						clearSelection();			container.graphics.beginFill(_selectionColor, _selectionAlpha);			container.graphics.drawRect(beginX, 0, endX - beginX, height);			container.graphics.endFill();		}				private function updateCursor(event:MouseEvent):void {			if (!_selectable) {				Mouse.cursor = MouseCursor.AUTO;			} else {				Mouse.cursor = (event.type == MouseEvent.ROLL_OVER || event.buttonDown) ? MouseCursor.IBEAM : MouseCursor.AUTO;			}		}				private function showCursor():void {			if (anchorIndex != activeIndex) return;			cursorTimer.start();			_cursor.visible = true;						var cursorX:int = activeIndex - 1;			_cursor.x = cursorX < 0 ? line.getAtomBounds(0).left : line.getAtomBounds(cursorX).right;		}				private function hideCursor():void {			cursorTimer.stop();			_cursor.visible = false;		}				private function flashCursor(event:TimerEvent):void {			_cursor.visible = !_cursor.visible;		}				private function panText():void {			var newX:Number = _scrollRect.x;			if (empty) {				newX = defaultScrollRect.x;				if (_align == TextFormatAlign.RIGHT) newX = newX - defaultScrollRect.width + (_cursor.width || 1);			} else if (activeIndex == 0 && _align != TextFormatAlign.RIGHT) {				newX = defaultScrollRect.x;			} else {				var bounds:Rectangle = line.getAtomBounds(Math.max(0, activeIndex - 1))				var activeX:Number = activeIndex < 0 ? bounds.left : bounds.right;				activeX += (_cursor.width || 1);				if (activeX < _scrollRect.left) {					if (_align == TextFormatAlign.RIGHT) newX = defaultScrollRect.x; 					else newX = Math.max(defaultScrollRect.left, activeX - _format.fontSize);				} else if (activeX > _scrollRect.right) {					newX = activeX - defaultScrollRect.width;					if (_align != TextFormatAlign.RIGHT) newX += _format.fontSize;				}			}						_scrollRect.x = newX;			container.scrollRect = _scrollRect;		}				private function focusIn(event:FocusEvent):void {			if (!_selectable) return;			if (!focusedIn) {				focusedIn = true;				selectAll();			}		}				private function focusOut(event:FocusEvent = null):void {			if (!_selectable) return;			if (event && !event.relatedObject && base.getRect(base).contains(base.mouseX, base.mouseY)) return;			focusedIn = false;			redrawTextLine();			clearSelection();			hideCursor();		}				private function handleKeyboard(event:KeyboardEvent):void {						if (!_selectable) return;						var dirtyText:Boolean = false;			var leftIndex:int, rightIndex:int;			var newCharIndex:int = -1;			var altDown:Boolean = event.altKey;			var modDown:Boolean = event.ctrlKey;			var shiftDown:Boolean = event.shiftKey;			var word:Object, wordChars:String;						leftIndex = Math.min(anchorIndex, activeIndex);			rightIndex = Math.max(anchorIndex, activeIndex);						switch (event.keyCode) {				case Keyboard.ENTER:					dispatchEvent(COMPLETE_EVENT);				case Keyboard.ESCAPE:					stage.focus = stage;					focusOut();				return;				case Keyboard.BACKSPACE:					if (_editable) {						if (altDown && rightIndex > 0) {							do {								word = getWordUnderCursor(rightIndex - 1, false);								wordChars = _text.substring(word.start, word.end + 1);								leftIndex = word.start;								newCharIndex = splice(leftIndex, rightIndex);								rightIndex--;							} while (wordChars == " ");						} else if (modDown && leftIndex == rightIndex) {							newCharIndex = splice(0, rightIndex);						} else {							newCharIndex = splice(leftIndex, rightIndex);						}											dirtyText = true;					}				break;				case Keyboard.LEFT:					if (altDown) {						if (indicesUnspecified && anchorIndex != activeIndex) {							anchorIndex = rightIndex;							activeIndex = leftIndex;						}						indicesUnspecified = false;						if (leftIndex > 0) {							word = getWordUnderCursor(leftIndex, false);							wordChars = _text.substring(word.start, word.end + 1);							while (word && word.isWhitespace) {								word = getWordUnderCursor(word.start - 1, false);								wordChars = _text.substring(word.start, word.end + 1);							}							if (word.start != leftIndex) {								activeIndex = word.start;							} else {								do {									word = getWordUnderCursor(word.start - 2, false);									wordChars = _text.substring(word.start, word.end + 1);									activeIndex = word.start;								} while (wordChars == " ");							}						}						if (!shiftDown) anchorIndex = activeIndex;					} else {						if (!shiftDown && anchorIndex != activeIndex) {							anchorIndex = activeIndex = Math.min(anchorIndex, activeIndex);						} else {							activeIndex = modDown ? 0 : Math.max(0, activeIndex - 1);							if (!shiftDown) anchorIndex = activeIndex;						}					}					wordMode = false;				break;				case Keyboard.RIGHT:					if (altDown) {						if (indicesUnspecified && anchorIndex != activeIndex) {							anchorIndex = leftIndex;							activeIndex = rightIndex;						}												indicesUnspecified = false;												if (rightIndex < _text.length) {							word = getWordUnderCursor(Math.max(0, rightIndex - 1), false);							wordChars = _text.substring(word.start, word.end + 1);							while (word && word.isWhitespace) {								word = getWordUnderCursor(word.end + 1, false);								wordChars = _text.substring(word.start, word.end + 1);							}							if (word.end != rightIndex) {								activeIndex = word.end;							} else {								do {									word = getWordUnderCursor(word.end + 1, false);									wordChars = _text.substring(word.start, word.end + 1);									activeIndex = word.end;								} while (wordChars == " ");							}						}												if (!shiftDown) anchorIndex = activeIndex;					} else {						if (!shiftDown && anchorIndex != activeIndex) {							anchorIndex = activeIndex = Math.max(anchorIndex, activeIndex);						} else {							activeIndex = modDown ? _text.length : Math.min(_text.length, activeIndex + 1);							if (!shiftDown) anchorIndex = activeIndex;						}						wordMode = false;					}				break;				case Keyboard.UP:					activeIndex = 0;					if (!shiftDown) anchorIndex = activeIndex;					wordMode = false;				break;				case Keyboard.DOWN:					activeIndex = _text.length;					if (!shiftDown) anchorIndex = activeIndex;					wordMode = false;				break;				case Keyboard.SHIFT:				case Keyboard.CONTROL:				case Keyboard.TAB:				break;				default:					var input:String = String.fromCharCode(event.charCode);					if (modDown) {						//trace("⌘ " + input);						switch (input) {							case "z": /* UNDO */ break;							case "y":							case "Z": /* REDO */ break;						}					} else if (_editable) {						wordMode = false;						if (charLimiter) input = input.replace(charLimiter, "");						if (input.length) {							newCharIndex = splice(leftIndex, rightIndex, input);							dirtyText = true;						}					}				break;			}						if (dirtyText) {				activeIndex = anchorIndex = Math.max(0, Math.min(_text.length, newCharIndex));				redrawTextLine();				dispatchEvent(CHANGE_EVENT);			}						indicesUnspecified = false;			redrawSelection();			hideCursor();			showCursor();			panText();		}				private function handleClipboard(event:Event):void {						if (!_selectable) return;						var dirtyText:Boolean = false;			var leftIndex:int, rightIndex:int;			var newCharIndex:int = -1;						leftIndex = Math.min(anchorIndex, activeIndex);			rightIndex = Math.max(anchorIndex, activeIndex);						switch (event.type) {				case Event.SELECT_ALL: selectAll(); break;				case Event.CUT: 					if (_editable) {						newCharIndex = cut(leftIndex, rightIndex); dirtyText = true; 					}				break;				case Event.COPY: copy(leftIndex, rightIndex); break;				case Event.PASTE: 					if (_editable) {						newCharIndex = paste(leftIndex, rightIndex); 						dirtyText = newCharIndex > 0;					}				break;			}						if (dirtyText) {				activeIndex = anchorIndex = Math.max(0, Math.min(_text.length, newCharIndex));				redrawTextLine();				dispatchEvent(CHANGE_EVENT);			}						indicesUnspecified = false;			redrawSelection();			hideCursor();			showCursor();			panText();		}				private function cut(from:int, to:int):int {			if (from == to) return from;			copy(from, to);			return splice(from, to);		}				private function copy(from:int, to:int):void {			if (from == to) return;			Clipboard.generalClipboard.clear();			Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, _text.substring(from, to));		}				private function paste(from:int, to:int):int {			if(!Clipboard.generalClipboard.hasFormat(ClipboardFormats.TEXT_FORMAT)) return -1;			var candidate:String = Clipboard.generalClipboard.getData(ClipboardFormats.TEXT_FORMAT).toString();			if (charLimiter) candidate = candidate.replace(charLimiter, "");			return splice(from, to, candidate.replace(/[\r\n\t]/g, ""));		}				private function splice(from:int, to:int, insert:String = ""):int {			var oldLen:int = _text.length;						if (empty) {				empty = false;				if (_maxChars) insert = insert.substr(0, _maxChars);				_text = insert;				_txet = insert.length == 1 ? insert : insert.split("").reverse().join("");				return insert.length;			}						if (from == to && !insert.length) {				from--;				if (from < 0) return 0;				_text = _text.substring(0, from) + _text.substring(to);				_txet = _txet.substring(0, oldLen - to) + _txet.substring(oldLen - from);				return from;			}						if (wordMode) {				if (from == 0) {					if (to < oldLen - 2 && _text.charAt(to) == " " && _text.charAt(to + 1) != " ") to++;				} else {					if (from > 1 && _text.charAt(from - 1) == " " && _text.charAt(from - 2) != " ") from--;				}			}									if (_maxChars) insert = insert.substr(0, _maxChars - (_text.length - (to - from)));						var tresni:String = insert.length > 1 ? insert : insert.split("").reverse().join("");			_text = _text.substring(0, from) + insert + _text.substring(to);			_txet = _txet.substring(0, oldLen - to) + tresni + _txet.substring(oldLen - from);			return from + insert.length;		}	}}