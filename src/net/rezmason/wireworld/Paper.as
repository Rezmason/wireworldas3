/*** Wireworld Player by Jeremy Sachs. June 8, 2010** Feel free to distribute the source, just try not to hand it off to some douchebag.* Keep this header here.** Please contact jeremysachs@rezmason.net prior to distributing modified versions of this class.*/package net.rezmason.wireworld {		//---------------------------------------	// IMPORT STATEMENTS	//---------------------------------------		import flash.display.BitmapData;	import flash.display.Graphics;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.ColorTransform;		// The Paper is used to display information from the current model,	// as well as other information that should be "connected" to it.		internal final class Paper extends Sprite {				//---------------------------------------		// PRIVATE VARIABLES		//---------------------------------------		private var firstWidth:int;		private var limitWidth:int, limitHeight:int;		private var homeScale:Number = 1;		private var displayBase:Shape;		private var displayWires:Shape;		private var displayHeads:Shape;		private var displayTails:Shape;		private var displayHeat:Shape;		private var displayGraph:Sprite = new Sprite;		private var _showHeat:Boolean = false;		private var ike:int;		private var scratch:Number;				//---------------------------------------		// CONSTRUCTOR		//---------------------------------------		public function Paper(__width:int = 0, __height:int = 0):void {			limitWidth = __width;			limitHeight = __height;		}				//---------------------------------------		// GETTER / SETTERS		//---------------------------------------				internal function get paperWidth():int {			return limitWidth;		}				internal function get paperHeight():int {			return limitHeight;		}				//---------------------------------------		// INTERNAL METHODS		//---------------------------------------				// Connects the Paper to the Model.				internal function init(base:Graphics, wire:Graphics, head:Graphics, tail:Graphics, heat:Graphics, palette:ColorPalette):void {						homeScale = scaleX = scaleY = 1;			displayBase ||= new Shape();			displayWires ||= new Shape();			displayHeads ||= new Shape();			displayTails ||= new Shape();			displayHeat ||= new Shape();						copyData(displayBase, base);			copyData(displayWires, wire);			copyData(displayHeads, head);			copyData(displayTails, tail);			copyData(displayHeat, heat);						changeColor(palette);						addChild(displayBase);			addChild(displayGraph);			displayGraph.addChild(displayWires);			displayGraph.addChild(displayTails);			displayGraph.addChild(displayHeads);			addChild(displayHeat);						_showHeat = false;			displayGraph.visible = true;			displayHeat.visible = false;						if (width * height < limitWidth * limitHeight * 0.4) {				if (height / width > limitHeight / limitWidth) {					height = limitHeight;					scaleX = scaleY;				} else {					width = limitWidth;					scaleY = scaleX;				}				homeScale = scaleX;			}			if (height < limitHeight) {				y = (limitHeight - height) / 2;			} else {				y = 24;			}			firstWidth = width;		}				internal function reset():void {			scaleY = scaleX = homeScale;			x = (limitWidth - width ) / 2;			if (height < limitHeight) {				y = (limitHeight - height) / 2;			} else {				y = 24;			}		}				internal function reposition(__width:int, __height:int):void {			x -= limitWidth / 2;			y -= limitHeight / 2;			limitWidth = __width;			limitHeight = __height;			x += limitWidth / 2;			y += limitHeight / 2;		}				// Continuous zoom under the mouse		internal function zoomBy(event:MouseEvent = null, delta:Number = NaN):void {			if (isNaN(delta)) delta = event.delta * 0.01; 			if (delta < 0 && width * (1 + delta) < 0.1 * firstWidth) return;			if (delta > 0 && width * (1 + delta) > 400 * firstWidth) return;			width *= 1 + delta;			height *= 1 + delta;			x -= delta * (stage.mouseX - x);			y -= delta * (stage.mouseY - y);			event.updateAfterEvent();		}				// Discrete zooms- in and out.		internal function zoomIn(event:MouseEvent = null):void {			if (width * 1.25 > 400 * firstWidth) return;						scratch = Math.round(width / 100) * 100;			scratch *= 1.25 / width;			if (Math.abs(width * scratch - firstWidth) < 10) {				scratch = firstWidth / width;			}			width *= scratch;			height *= scratch;			scratch--;			x -= scratch * (limitWidth  / 2 - x);			y -= scratch * (limitHeight / 2 - y);			event.updateAfterEvent();		}				internal function zoomOut(event:MouseEvent = null):void {			if (width * 0.8 < 0.1 * firstWidth) return;			scratch = Math.round(width / 100) * 100;			scratch *= 0.8 / width;			if (Math.abs(width * scratch - firstWidth) < 10) {				scratch = firstWidth / width;			}			width *= scratch;			height *= scratch;			scratch--;			x -= scratch * (limitWidth  / 2 - x);			y -= scratch * (limitHeight / 2 - y);			event.updateAfterEvent();		}				// Spits out a snapshot of itself.		internal function print():BitmapData {			var output:BitmapData = new BitmapData(displayBase.width, displayBase.height, false, 0);			output.draw(displayGraph);			return output;		}				// Switches between the normal and heat views.		internal function toggleHeat(event:Event = null):void {			_showHeat = !_showHeat;			displayHeat.visible = !displayHeat.visible;			displayGraph.visible = !displayGraph.visible;		}				//---------------------------------------		// PRIVATE METHODS		//---------------------------------------				// Some small helper functions				private function copyData(shape:Shape, graphicsObject:Graphics):void {			shape.graphics.clear();			shape.graphics.copyFrom(graphicsObject);		}				private function changeColor(_colorPalette:ColorPalette):void {			var colorTransform:ColorTransform = new ColorTransform;						colorTransform.color = _colorPalette.dead;			displayBase.transform.colorTransform = colorTransform;						colorTransform.color = _colorPalette.wire;			displayWires.transform.colorTransform = colorTransform;						colorTransform.color = _colorPalette.head;			displayHeads.transform.colorTransform = colorTransform;						colorTransform.color = _colorPalette.tail;			displayTails.transform.colorTransform = colorTransform;		}	}}