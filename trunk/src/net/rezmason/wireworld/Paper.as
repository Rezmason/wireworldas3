/*** Wireworld Player by Jeremy Sachs. June 22, 2010** Feel free to distribute the source, just try not to hand it off to some douchebag.* Keep this header here.** Please contact jeremysachs@rezmason.net prior to distributing modified versions of this class.*/package net.rezmason.wireworld {		//---------------------------------------	// IMPORT STATEMENTS	//---------------------------------------		import apparat.math.FastMath;		import flash.display.BitmapData;	import flash.display.Graphics;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;		// The Paper is used to display information from the current model,	// as well as other information that should be "connected" to it.		internal final class Paper extends Sprite {				//---------------------------------------		// PRIVATE VARIABLES		//---------------------------------------		private var dragging:Boolean = false;		private var firstWidth:int;		private var limitWidth:int, limitHeight:int;		private var homeScale:Number = 1;		private var displayBase:Shape;		private var displayWires:Shape;		private var displayHeads:Shape;		private var displayTails:Shape;		private var displayHeat:Shape;		private var displayGraph:Sprite = new Sprite;		private var _showHeat:Boolean = false;		private var _minZoom:Number = 0.1, _maxZoom:Number = 350;		private var topBound:int, leftBound:int, bottomBound:int, rightBound:int;		private var _setBounds:Function;		private var oppScale:Number;		private var ike:int;		private var scratch:Number;				//private var canvas:Shape = new Shape();				//---------------------------------------		// CONSTRUCTOR		//---------------------------------------		public function Paper(__width:int = 0, __height:int = 0, __setBounds:Function = null):void {			limitWidth = __width;			limitHeight = __height;			_setBounds = __setBounds;		}				//---------------------------------------		// GETTER / SETTERS		//---------------------------------------				internal function get paperWidth():int {			return limitWidth;		}				internal function get paperHeight():int {			return limitHeight;		}				internal function get atMinZoom():Boolean {			return scaleX <= _minZoom;		}				internal function get atMaxZoom():Boolean {			return scaleX >= _maxZoom;		}				//---------------------------------------		// INTERNAL METHODS		//---------------------------------------				// Connects the Paper to the Model.				internal function init(base:Graphics, wire:Graphics, head:Graphics, tail:Graphics, heat:Graphics, palette:ColorPalette):void {						displayBase ||= new Shape();			displayWires ||= new Shape();			displayHeads ||= new Shape();			displayTails ||= new Shape();			displayHeat ||= new Shape();						copyData(displayBase, base);			copyData(displayWires, wire);			copyData(displayHeads, head);			copyData(displayTails, tail);			copyData(displayHeat, heat);						changeColor(palette);						addChild(displayBase);			addChild(displayGraph);			displayGraph.addChild(displayWires);			displayGraph.addChild(displayTails);			displayGraph.addChild(displayHeads);			addChild(displayHeat);			//addChild(canvas);						_showHeat = false;			displayGraph.visible = true;			displayHeat.visible = false;						reset();		}				internal function reset():void {			//canvas.graphics.clear();						homeScale = scaleX = scaleY = 1;			if (width * height < limitWidth * limitHeight * 0.4) {				if (height / width > limitHeight / limitWidth) {					height = limitHeight;					scaleX = scaleY;				} else {					width = limitWidth;					scaleY = scaleX;				}				homeScale = scaleX;			}			if (height < limitHeight) {				y = (limitHeight - height) / 2;			} else {				y = 24;			}			firstWidth = width;						x = (limitWidth - width ) / 2;			if (height < limitHeight) {				y = (limitHeight - height) / 2;			} else {				y = 24;			}			oppScale = 1 / scaleX;			updateBounds();		}				internal function reposition(__width:int, __height:int):void {			x -= limitWidth / 2;			y -= limitHeight / 2;			limitWidth = __width;			limitHeight = __height;			x += limitWidth / 2;			y += limitHeight / 2;						updateBounds();		}				// Continuous zoom under the mouse		internal function zoomBy(event:MouseEvent = null, delta:Number = NaN, underX:Number = NaN, underY:Number = NaN):void {			if (isNaN(delta)) delta = event.delta * 0.01;			scratch = FastMath.min(FastMath.max((1 + delta) * scaleX, _minZoom), _maxZoom);			if (scaleX != scratch) {				delta = scratch / scaleX - 1;				scaleX = scaleY = scratch;				if (isNaN(underX)) underX = limitWidth  * 0.5;				if (isNaN(underY)) underY = limitHeight * 0.5;				x -= delta * (underX - x);				y -= delta * (underY - y);				if (event) event.updateAfterEvent();			}			oppScale = 1 / scaleX;			updateBounds();		}				// Spits out a snapshot of itself.		internal function print():BitmapData {			var output:BitmapData = new BitmapData(displayBase.width, displayBase.height, false, 0);			output.draw(displayGraph);			return output;		}				// Switches between the normal and heat views.		internal function toggleHeat(event:Event = null):void {			_showHeat = !_showHeat;			displayHeat.visible = !displayHeat.visible;			displayGraph.visible = !displayGraph.visible;		}				// Dragging functions				internal function beginDrag(event:Event = null):void {			if (dragging) return;			dragging = true;			stage.addEventListener(MouseEvent.MOUSE_MOVE, updateBounds, false, 0, true);			startDrag();		}				internal function endDrag(event:Event = null):void {			if (!dragging) return;			dragging = false;			stage.removeEventListener(MouseEvent.MOUSE_MOVE, updateBounds);			updateBounds();			stopDrag();		}				//---------------------------------------		// PRIVATE METHODS		//---------------------------------------				// Some small helper functions				private function copyData(shape:Shape, graphicsObject:Graphics):void {			shape.graphics.clear();			shape.graphics.copyFrom(graphicsObject);		}				private function changeColor(_colorPalette:ColorPalette):void {			var colorTransform:ColorTransform = new ColorTransform;						colorTransform.color = _colorPalette.dead;			displayBase.transform.colorTransform = colorTransform;						colorTransform.color = _colorPalette.wire;			displayWires.transform.colorTransform = colorTransform;						colorTransform.color = _colorPalette.head;			displayHeads.transform.colorTransform = colorTransform;						colorTransform.color = _colorPalette.tail;			displayTails.transform.colorTransform = colorTransform;		}				// finds the rectangle which contains all pixels that are onscreen				private function updateBounds(event:Event = null):void {			if (_setBounds == null) return;			//canvas.graphics.clear();			topBound = 		int(FastMath.max(-y, 0) * oppScale) - 1;			leftBound = 	int(FastMath.max(-x, 0) * oppScale) - 1;			bottomBound =	int(FastMath.min(height, stage.stageHeight - y) * oppScale) + 1;			rightBound = 	int(FastMath.min(width, stage.stageWidth - x) * oppScale) + 1;			_setBounds(topBound, leftBound, bottomBound, rightBound);			//canvas.graphics.lineStyle(0, 0xFFFF00);			//canvas.graphics.drawEllipse(leftBound, topBound, rightBound - leftBound, bottomBound - topBound);		}	}}