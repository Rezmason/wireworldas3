/*** Wireworld Player by Jeremy Sachs. June 22, 2010** Feel free to distribute the source, just try not to hand it off to some douchebag.* Keep this header here.** Please contact jeremysachs@rezmason.net prior to distributing modified versions of this class.*/package net.rezmason.wireworld {		//---------------------------------------	// IMPORT STATEMENTS	//---------------------------------------	import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.filters.GlowFilter;		// Handles the announcers, to a degree. They're pretty self-maintaining.		internal final class AnnouncerManager extends EventDispatcher {				//---------------------------------------		// PRIVATE VARIABLES		//---------------------------------------		private var announcers:Vector.<Announcer> = new <Announcer>[];		private var glow:GlowFilter = new GlowFilter(0xA0A0A0, 1, 10, 10, 1.5, 2);		private var currentAnnouncer:Announcer;		private var paper:Paper;		private var _model:IModel;		private var num:int = 0;				//---------------------------------------		// CONSTRUCTOR		//---------------------------------------		public function AnnouncerManager(__paper:Paper):void {			paper = __paper;		}				//---------------------------------------		// GETTER / SETTERS		//---------------------------------------				internal function get selectedAnnouncer():Announcer {			return currentAnnouncer;		}				internal function set model(__model:IModel):void {			disposeAnnouncers();			_model = __model;		}				//---------------------------------------		// INTERNAL METHODS		//---------------------------------------				internal function makeNewAnnouncer():void {						if (currentAnnouncer) {				currentAnnouncer.filters = [];			}						currentAnnouncer = new Announcer(paper, _model);			announcers.push(currentAnnouncer);			currentAnnouncer.name = "flag_" + (++num);			currentAnnouncer.scaleX = currentAnnouncer.scaleY = (paper.scaleX < 1 ? 1 : (1 / paper.scaleX));			currentAnnouncer.filters = [glow];			currentAnnouncer.addEventListener(WWEvent.ANNOUNCER_SELECT, selectAnnouncer, false, 0, true);			currentAnnouncer.addEventListener(WWEvent.ANNOUNCER_REMOVE, removeAnnouncer, false, 0, true);			zSortAnnouncers();		}				internal function addAnnouncers():void {						var ike:int;						for (ike = 0; ike < announcers.length; ike++) {				paper.addChild(announcers[ike]);			}		}				// Announcers scale slightly differently than the paper		// they're tacked to. They have a minimum size.				internal function scaleAnnouncers():void {						var ike:int;			var scaleVal:Number = (paper.scaleX < 1 ? 1 : (1 / paper.scaleX));						for (ike = 0; ike < announcers.length; ike++) {				announcers[ike].scaleX = announcers[ike].scaleY = scaleVal;			}		}				internal function removeAnnouncers():void {						var ike:int;						for (ike = 0; ike < announcers.length; ike++) {				paper.removeChild(announcers[ike]);			}		}				internal function disposeAnnouncers():void {			if (currentAnnouncer) {				currentAnnouncer.filters = [];				currentAnnouncer = null;			}						removeAnnouncers();						announcers = new <Announcer>[];						num = 0;		}				internal function deselectAnnouncers():void {			if (currentAnnouncer) {				currentAnnouncer.filters = [];				currentAnnouncer = null;			}			zSortAnnouncers();		}				internal function updateAnnouncers():void {						var ike:int;						for (ike = 0; ike < announcers.length; ike++) {				announcers[ike].update();			}		}				private function zSortAnnouncers(event:Event = null):void {						var ike:int;						announcers.sort(Announcer.zSort);						for (ike = 0; ike < announcers.length; ike++) {				paper.addChild(announcers[ike]);			}						if (currentAnnouncer) {				paper.addChild(currentAnnouncer);			}		}				//---------------------------------------		// PRIVATE METHODS		//---------------------------------------				private function removeAnnouncer(event:Event):void {						announcers.splice(announcers.indexOf(event.currentTarget), 1);						paper.removeChild(event.currentTarget as DisplayObject);			event.target.removeEventListener(WWEvent.ANNOUNCER_SELECT, selectAnnouncer);			event.target.removeEventListener(WWEvent.ANNOUNCER_REMOVE, removeAnnouncer);			dispatchEvent(event);		}				private function selectAnnouncer(event:Event):void {						var ike:int;						if (currentAnnouncer) {				if (currentAnnouncer == event.target as Announcer) {					dispatchEvent(event);					return;				} else {					currentAnnouncer.filters = [];				}			}						currentAnnouncer = event.target as Announcer;			paper.setChildIndex(currentAnnouncer, paper.numChildren - 1);			currentAnnouncer.filters = [glow];			zSortAnnouncers();			dispatchEvent(event);		}	}}