/*** Wireworld Player by Jeremy Sachs. June 22, 2010** Feel free to distribute the source, just try not to hand it off to some douchebag.* Keep this header here.** Please contact jeremysachs@rezmason.net prior to distributing modified versions of this class.*/package net.rezmason.wireworld {	//---------------------------------------	// IMPORT STATEMENTS	//---------------------------------------	import __AS3__.vec.Vector;		import apparat.math.FastMath;	import apparat.math.IntMath;		import com.pixelbreaker.ui.osx.MacMouseWheel;		import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.Sprite;	import flash.display.Stage;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.events.SecurityErrorEvent;	import flash.events.TextEvent;	import flash.events.TimerEvent;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.system.Security;	import flash.text.Font;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.text.TextFormatAlign;	import flash.ui.Mouse;	import flash.utils.ByteArray;	import flash.utils.Dictionary;	import flash.utils.Timer;		import net.rezmason.display.Grid;	import net.rezmason.gui.SimpleBridge;	import net.rezmason.gui.Toolbar;	import net.rezmason.gui.ToolbarAlign;	import net.rezmason.net.Syphon;		// This class is responsible for managing all visual assets and the display of all information.		internal final class View extends EventDispatcher {				//---------------------------------------		// CLASS CONSTANTS		//---------------------------------------				private static const CHANGE_STATE_EVENT:Event = new Event(WWCommand.CHANGE_STATE);		private static const CLICK_EVENT:MouseEvent = new MouseEvent(MouseEvent.CLICK);				private static const BACK_DARK_CT:ColorTransform 	= new ColorTransform(0, 0, 0, 1, 0x60, 0x60, 0x60);		private static const BACK_MED_CT:ColorTransform 	= new ColorTransform(0, 0, 0, 1, 0x90, 0x90, 0x90);		private static const BACK_LIGHT_CT:ColorTransform 	= new ColorTransform(0, 0, 0, 1, 0xD0, 0xD0, 0xD0);		private static const FRONT_CT:ColorTransform     	= new ColorTransform(0, 0, 0, 1, 0x20, 0x20, 0x20);		private static const FRONT_TEXT_CT:ColorTransform	= new ColorTransform(0, 0, 0, 1, 0xFF, 0xFF, 0xFF);				private static const PLAIN_CT:ColorTransform = new ColorTransform;		private static const TOGGLED_CT:ColorTransform = new ColorTransform(1, 1, 1, 1, 90, 90, 90);		private static const INVERTED_CT:ColorTransform = new ColorTransform(-1, -1, -1, 1, 0xFF, 0xFF, 0xFF);				private static const OPAQUE_BACKGROUND_COLOR:int = 0x222222;				private static const READY_EVENT:WWEvent = new WWEvent(WWEvent.READY);				private static const RESOURCE_URL:String = "../lib/resources.swf";				private static const FONT_SIZE:int = 8;				//---------------------------------------		// PRIVATE VARIABLES		//---------------------------------------		private var _controller:Controller;		private var _model:IModel;		private var _scene:Sprite;				private var tooFarX:Boolean, tooFarY:Boolean;		private var defaultLabelText:String = "<label>";		private var mousePoint:Point = new Point();		private var hintTimer:Timer = new Timer(1000, 5);		private var txtGeneration:TextField = new TextField();		private var txtFPS:TextField = new TextField();		private var hint:TextField = new TextField();		private var textFormat:TextFormat = new TextFormat("Monaco", 14, 0x999999, true);		private var rightFormat:TextFormat = new TextFormat("Monaco", 14, 0x999999, true, null, null, null, null, TextFormatAlign.RIGHT);		private var hintFormat:TextFormat = new TextFormat("Monaco", 10);		private var labelFormat:TextFormat, inactiveLabelFormat:TextFormat;		private var target:DisplayObject;		private var toolbar1:Toolbar, toolbar2:Toolbar;		private var disabler:Sprite = new Sprite();		private var resetButton:MovieClip;		private var eraserToolButton:MovieClip;		private var handToolButton:MovieClip;		private var loadButton:MovieClip;		private var announcerLabel:MovieClip;		private var fileNameDisplay:MovieClip;		private var aboutBox:MovieClip;		private var galleryBox:MovieClip;		private var helpBox:MovieClip;		private var urlBox:MovieClip;		private var alertBox:MovieClip;		private var alertProgressIndicator:Shape;		private var alertProgressStripe:BitmapData;		private var alertProgressMat:Matrix;		private var resetPrompt:MovieClip;		private var loadPrompt:MovieClip;		private var handCursor:MovieClip;		private var eraserCursor:MovieClip;		private var cursor:MovieClip;		private var ratioSlider:MovieClip;		private var sliderGrip:Number;		private var draggingSlider:Boolean = false;		private var _announcer:Announcer;		private var grid:Grid;		private var paper:Paper;		private var announcerManager:AnnouncerManager;		private var toggleButtonStates:Dictionary = new Dictionary;		private var toggleButtons:Object = {};		private var _fileName:String;		private var uiScale:Number;		private var resizeX:int, resizeY:int;		private var translator:Point = new Point();		private var scratch:Number, scratch2:Number;		private var elements:Vector.<MovieClip> = new <MovieClip>[];		private var buttonSets:Object = {};		private var currentTool:String;		private var cursorsByButtonName:Object = {};		private var toolsByButtonName:Object = {};		private var toolButtonsByButtonName:Object = {};		private var updateHeat:Boolean = false;		private var _flag:int = 0;				private var _callback:Function;				private var heatButton:MovieClip, overdriveButton:MovieClip;				private var stage:Stage;		private var windowResizing:Boolean = false;		private var window:EventDispatcher;		private var _bridge:SimpleBridge;		private var disablerIndex:int;				private var font:Font;				private static var drawPoint:Point = new Point, drawMatrix:Matrix = new Matrix;		private static var creditBox:TextField = new TextField;		private static var creditFormat:TextFormat = new TextFormat;				//---------------------------------------		// CONSTRUCTOR		//---------------------------------------		public function View(__model:IModel, __scene:Sprite, __bridge:SimpleBridge):void {					_scene = __scene;			_model = __model;			_bridge = __bridge;			_bridge.eventTypes.CHANGE_STATE ||= WWCommand.CHANGE_STATE;			buildAPI();						_scene.opaqueBackground = OPAQUE_BACKGROUND_COLOR;						// Syphon is a tool for loading a SWF and extracting its art.			if (Syphon.library.AboutBox) {				proceed();			} else {				Syphon.addEventListener(Event.COMPLETE, proceed);				Syphon.load(RESOURCE_URL);			}		}				//---------------------------------------		// GETTER / SETTERS		//---------------------------------------				// updates the announcer label when the current announcer changes.		internal function set announcer(value:Announcer):void {			_announcer = value;						if (_announcer == null) {				announcerLabel.textBox.defaultTextFormat = inactiveLabelFormat;				announcerLabel.textBox.text = defaultLabelText;				announcerLabel.mouseEnabled = announcerLabel.mouseChildren = false;			} else {				announcerLabel.textBox.defaultTextFormat = labelFormat;				announcerLabel.textBox.text = _announcer.name;				announcerLabel.mouseEnabled = announcerLabel.mouseChildren = true;			}		}				// this callback is how the View propagates events to the Controller.		internal function set callback(func:Function):void {			_callback = func;		}				//---------------------------------------		// INTERNAL METHODS		//---------------------------------------				internal function isReady():Boolean {			return stage != null;		}				internal function addGUIEventListeners():void {						stage.addEventListener(MouseEvent.MOUSE_MOVE, moveCursor, false, 0, true);			stage.addEventListener(Event.MOUSE_LEAVE, hideCursor, false, 0, true);			stage.addEventListener(Event.MOUSE_LEAVE, drop, false, 0, true);			stage.addEventListener(MouseEvent.MOUSE_UP, drop, false, 0, true);			stage.addEventListener(MouseEvent.MOUSE_UP, openCursor, false, 0, true);			stage.addEventListener(MouseEvent.CLICK, stopHintTimer, false, 0, true);			stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpGUIMovieClip, false, 0, true);			stage.addEventListener(Event.ACTIVATE, changeActiveStatus, false, 0, true);			stage.addEventListener(Event.DEACTIVATE, changeActiveStatus, false, 0, true);						helpBox.closeButton.addEventListener(MouseEvent.CLICK, hideHelp);			urlBox.cancelButton.addEventListener(MouseEvent.CLICK, hideURLBox);			urlBox.loadButton.addEventListener(MouseEvent.CLICK, hideURLBox);			aboutBox.closeButton.addEventListener(MouseEvent.CLICK, hideAbout);			alertBox.closeButton.addEventListener(MouseEvent.CLICK, hideAlert);			galleryBox.cancelButton.addEventListener(MouseEvent.CLICK, hideExampleGallery);						// paper dragging and viewing			grid.addEventListener(MouseEvent.MOUSE_MOVE, yellPause);			paper.addEventListener(MouseEvent.MOUSE_MOVE, yellPause);			grid.addEventListener(MouseEvent.ROLL_OUT, hideCursor);			paper.addEventListener(MouseEvent.ROLL_OUT, hideCursor);			toolbar1.addEventListener(MouseEvent.ROLL_OVER, hideCursor);			toolbar2.addEventListener(MouseEvent.ROLL_OVER, hideCursor);			grid.addEventListener(MouseEvent.MOUSE_WHEEL, zoom);			paper.addEventListener(MouseEvent.MOUSE_WHEEL, zoom);						grid.addEventListener(MouseEvent.MOUSE_DOWN, lift);			paper.addEventListener(MouseEvent.MOUSE_DOWN, lift);			announcerManager.addEventListener(WWEvent.ANNOUNCER_SELECT, getAnnouncer);			announcerManager.addEventListener(WWEvent.ANNOUNCER_SELECT, closeCursor);			announcerManager.addEventListener(WWEvent.ANNOUNCER_REMOVE, clearAnnouncerLabel);			resetPrompt.yesButton.addEventListener(MouseEvent.CLICK, hideResetPrompt);			resetPrompt.noButton.addEventListener(MouseEvent.CLICK, hideResetPrompt);			loadPrompt.cancelButton.addEventListener(MouseEvent.CLICK, hideLoadPrompt);			loadPrompt.diskButton.addEventListener(MouseEvent.CLICK, hideLoadPrompt);			loadPrompt.webButton.addEventListener(MouseEvent.CLICK, hideLoadPrompt);			announcerLabel.textBox.addEventListener(TextEvent.TEXT_INPUT, announcerLabelHandler);			hintTimer.addEventListener(TimerEvent.TIMER, showHint);			hintTimer.addEventListener(TimerEvent.TIMER_COMPLETE, hideHint);			_scene.addEventListener(MouseEvent.MOUSE_MOVE, resetHintTimer);			_scene.addEventListener(MouseEvent.MOUSE_DOWN, resetHintTimer);			_scene.addEventListener(MouseEvent.MOUSE_OUT, stopHintTimer);								}				internal function setFileName(__fileName:String):void {			_fileName = __fileName;		}				internal function showLoading():void {			announcer = null;			giveAlert("Loading", "Loading file " + _fileName + "...", false);		}				// initializes the View		internal function prime():void {			fileNameDisplay.textBox.text = _fileName;			hideAlert();			announcerManager.model = _model;						paper.init(				_model.baseGraphics, 				_model.wireGraphics, 				_model.headGraphics, 				_model.tailGraphics, 				_model.heatGraphics,				ColorPalette.appropriatePalette			); 		}				// wipes clean the elements of the View that are particular to the open document		internal function resetView(event:Event = null):void {			announcerManager.removeAnnouncers();			paper.reset();			announcerManager.addAnnouncers();			_bridge.state.atMinZoom = _bridge.state.atMaxZoom = false;			_bridge.dispatchEvent(CHANGE_STATE_EVENT);		}				// turns all toggles back to their default states		internal function resetToggles(event:Event = null):void {			for (var prop:String in toggleButtons) {				if (toggleButtonStates[toggleButtons[prop]] == true) {					toggleButtons[prop].dispatchEvent(new MouseEvent(MouseEvent.CLICK));				}			}		}				// passing mouse wheel events to the Paper.		internal function zoom(event:MouseEvent):void {			paper.zoomBy(event, NaN, stage.mouseX, stage.mouseY);			announcerManager.scaleAnnouncers();			_bridge.state.atMinZoom = paper.atMinZoom;			_bridge.state.atMaxZoom = paper.atMaxZoom;			yellPause();			_bridge.dispatchEvent(CHANGE_STATE_EVENT);		}				internal function zoomIn(event:MouseEvent = null):void {			paper.zoomBy(event, +0.2);			announcerManager.scaleAnnouncers();			_bridge.state.atMinZoom = paper.atMinZoom;			_bridge.state.atMaxZoom = paper.atMaxZoom;			_bridge.dispatchEvent(CHANGE_STATE_EVENT);		}				internal function zoomOut(event:MouseEvent = null):void {			paper.zoomBy(event, -0.2);			announcerManager.scaleAnnouncers();			_bridge.state.atMinZoom = paper.atMinZoom;			_bridge.state.atMaxZoom = paper.atMaxZoom;			_bridge.dispatchEvent(CHANGE_STATE_EVENT);		}				internal function placeAnnouncer(event:Event = null):void {			announcerManager.makeNewAnnouncer();			announcer = announcerManager.selectedAnnouncer;		}				internal function updateAnnouncers():void {			announcerManager.updateAnnouncers();		}				internal function showAbout(event:Event = null):void {			_scene.addChildAt(aboutBox, disablerIndex);			showDisabler();		}				internal function hideAbout(event:Event = null):void {			if (_scene.contains(aboutBox)) _scene.removeChild(aboutBox);			hideDisabler();		}				// Populates the alert box with a title, message, and maybe a close button		internal function giveAlert(titleText:String, messageText:String, allowClose:Boolean = true):void {			_scene.addChildAt(alertBox, disablerIndex);			showDisabler();			alertBox.title.text = titleText;			alertBox.message.text = messageText;			alertBox.closeButton.visible = allowClose;			alertProgressIndicator.visible = !allowClose;			if (alertProgressIndicator.visible) {				alertProgressIndicator.addEventListener(Event.ENTER_FRAME, updateAlertProgress);			}		}				internal function hideAlert(event:Event = null):void {			if (_scene.contains(alertBox)) {				hideDisabler();				_scene.removeChild(alertBox);				alertProgressIndicator.removeEventListener(Event.ENTER_FRAME, updateAlertProgress);			}		}				// resizes the View when the stage has changed dimensions		internal function resize(event:Event = null):void {			resizeX = FastMath.max(FastMath.max(toolbar1.minWidth, toolbar2.minWidth), stage.stageWidth);			resizeY = FastMath.max(160, stage.stageHeight);						// resize toolbars			uiScale = FastMath.max(1, resizeY / 600);			toolbar1.scale = toolbar2.scale = uiScale;			toolbar1.width = resizeX / uiScale;			toolbar2.width = resizeX / uiScale;			if (window) {				var minSize:Point = window["minSize"] as Point;				minSize.x = FastMath.max(toolbar1.minWidth, toolbar2.minWidth);				window["minSize"] = minSize;			}			toolbar2.y = resizeY - toolbar2.realHeight;						// reposition prompts			translator.x = (resetButton.x + resetButton.width  / 2) * uiScale;			translator.y = (resetButton.y + resetButton.height / 2) * uiScale;			translator = resetButton.parent.localToGlobal(translator);			resetPrompt.x = translator.x;			resetPrompt.y = translator.y;			//resetPrompt.scaleX = resetPrompt.scaleY = uiScale;						translator.x = (loadButton.x + loadButton.width  / 2) * uiScale;			translator.y = (loadButton.y + loadButton.height / 2) * uiScale;			translator = loadButton.parent.localToGlobal(translator);			loadPrompt.x = translator.x;			loadPrompt.y = translator.y;			//loadPrompt.scaleX = loadPrompt.scaleY = uiScale;						// redraw grid			grid.y = toolbar1.realHeight;			grid.width = resizeX;			grid.height = resizeY - (toolbar1.realHeight + toolbar2.realHeight);						// reposition paper			paper.reposition(resizeX, resizeY - (toolbar1.realHeight + toolbar2.realHeight));						// redraw disabler			disabler.width = resizeX;			disabler.height = resizeY;						// scale boxes (waiting for smoother text scaling— TLF)			/*			helpBox.scaleX = helpBox.scaleY = uiScale;			urlBox.scaleX = urlBox.scaleY = uiScale;			aboutBox.scaleX = aboutBox.scaleY = uiScale;			alertBox.scaleX = alertBox.scaleY = uiScale;			*/			// reposition boxes			centerBox(helpBox);			centerBox(urlBox);			centerBox(aboutBox);			centerBox(alertBox);			centerBox(galleryBox);		}				internal function updatePaper(flags:int = 0):void {			_model.refresh(flags | _flag);		}				internal function updateGeneration(gen:uint):void {			txtGeneration.text = gen.toString();		}				internal function updateFPS(__fps:int):void {			txtFPS.text = __fps.toString();		}				// Staples together a snapshot of the current Wireworld instance		// to a text field containing its description, stamped on a bitmap		internal function snapshot():BitmapData {			_model.refresh(WWRefreshFlag.FULL | WWRefreshFlag.TAIL);						var image:BitmapData = paper.print();						var credit:String = _model.credit;			if (credit) {				creditBox.height = image.height;				creditBox.text = credit;				var dlData:BitmapData = new BitmapData(image.width + creditBox.width, IntMath.max(image.height, creditBox.height), false, 0x000000);				drawPoint.x = creditBox.width;				drawMatrix.tx = creditBox.width;				dlData.copyPixels(image, image.rect, drawPoint);				dlData.draw(creditBox);				image = dlData;			}			return image;		}				// Disabler methods. This shows and hides a big dark transparent shape		// that goes behind modal dialogs to disable the rest of the GUI.				internal function showDisabler(event:Event = null):void {			_scene.addChildAt(disabler, disablerIndex);			grid.removeEventListener(MouseEvent.MOUSE_MOVE, showCursor);			paper.removeEventListener(MouseEvent.MOUSE_MOVE, showCursor);			hideCursor();			_bridge.state.interactive = false;			_bridge.dispatchEvent(CHANGE_STATE_EVENT);		}				internal function hideDisabler(event:Event = null):void {			if (_scene.contains(disabler)) _scene.removeChild(disabler);			grid.addEventListener(MouseEvent.MOUSE_MOVE, showCursor);			paper.addEventListener(MouseEvent.MOUSE_MOVE, showCursor);			if (grid.hitTestPoint(_scene.mouseX, _scene.mouseY)) showCursor();			_bridge.state.interactive = true;			_bridge.dispatchEvent(CHANGE_STATE_EVENT);		}				//---------------------------------------		// PRIVATE METHODS		//---------------------------------------				// Instantiates GUI elements once the Syphon has loaded the asset SWF.		private function proceed(event:Event = null):void {						Syphon.removeEventListener(Event.COMPLETE, proceed);							resetButton = new Syphon.library.ResetButton;			loadButton = new Syphon.library.LoadButton;			handToolButton = new Syphon.library.HandCursorButton;			eraserToolButton = new Syphon.library.EraserCursorButton;			announcerLabel = new Syphon.library.AnnouncerLabel;			fileNameDisplay = new Syphon.library.FileNameDisplay;			aboutBox = new Syphon.library.AboutBox;			aboutBox.tdsiMention.visible = BRAIN::TDSI || BRAIN::STANDARD;			galleryBox = new Syphon.library.GalleryBox;			helpBox = new Syphon.library.HelpBox;			urlBox = new Syphon.library.URLBox;			alertBox = new Syphon.library.AlertBox;			resetPrompt = new Syphon.library.ResetPrompt;			loadPrompt = new Syphon.library.LoadPrompt;			handCursor = new Syphon.library.HandCursor;			eraserCursor = new Syphon.library.BlockCursor;						var readmeLoader:URLLoader = new URLLoader();			readmeLoader.dataFormat = URLLoaderDataFormat.BINARY;			readmeLoader.data = new Syphon.library.README as ByteArray;			readmeLoader.dataFormat = URLLoaderDataFormat.TEXT;			helpBox.setText(readmeLoader.data);						alertProgressIndicator = new Shape();			alertProgressIndicator.transform.colorTransform = BACK_DARK_CT;			var alertBounds:Rectangle = alertBox.getBounds(alertBox);			alertProgressIndicator.x = alertBounds.left;			alertProgressIndicator.y = alertBounds.bottom - 25;			alertBox.addChild(alertProgressIndicator);			alertProgressStripe = new BitmapData(2, 1, true, 0x0);			alertProgressStripe.setPixel32(0, 0, 0xFF000000);			alertProgressMat = new Matrix(30, 0, -20, 20);						toolbar1 = new Toolbar(0, 24, OPAQUE_BACKGROUND_COLOR);			toolbar2 = new Toolbar(0, 24, OPAQUE_BACKGROUND_COLOR);			disabler.graphics.beginFill(0x000000, 0.5);			disabler.graphics.drawRect(0, 0, 100, 100);			disabler.graphics.endFill();						aboutBox.opaqueBackground = OPAQUE_BACKGROUND_COLOR;			alertBox.opaqueBackground = OPAQUE_BACKGROUND_COLOR;			helpBox.opaqueBackground = OPAQUE_BACKGROUND_COLOR;			urlBox.opaqueBackground = OPAQUE_BACKGROUND_COLOR;			galleryBox.opaqueBackground = OPAQUE_BACKGROUND_COLOR;						grid = new Grid(12, 0, 0);			paper = new Paper(0, 0, _model.setBounds);			announcerManager = new AnnouncerManager(paper);						loadPrompt.visible = false;			resetPrompt.visible = false;						// hand cursor			handCursor.mouseDownSprite.visible = false;			handCursor.mouseEnabled = handCursor.mouseChildren = false;			handCursor.x = handCursor.y = -100;						eraserCursor.mouseDownSprite.visible = false;			eraserCursor.mouseEnabled = eraserCursor.mouseChildren = false;			eraserCursor.x = eraserCursor.y = -100;			eraserCursor.visible = false;						// top left			setupGUIElement(resetButton, "Reset", showResetPrompt, 1, ToolbarAlign.LEFT, false);			setupGUIElement(new Syphon.library.PlayPauseButton, "Play/pause", WWCommand.TOGGLE_PLAY_PAUSE, 1, ToolbarAlign.LEFT, false);			setupGUIElement(new Syphon.library.StepButton, "Step", WWCommand.STEP, 1, ToolbarAlign.LEFT, false);			heatButton = setupGUIElement(new Syphon.library.HeatButton, "Toggle heat vision", toggleHeat, 1, ToolbarAlign.LEFT, false, ButtonTypes.TOGGLABLE) as MovieClip;			//setupGUIElement(new Syphon.library.Separator);			handToolButton = setupGUIElement(handToolButton, "Hand tool", setTool, 1, ToolbarAlign.LEFT, false, ButtonTypes.IN_A_SET, "toolButtons", true) as MovieClip;			eraserToolButton = setupGUIElement(eraserToolButton, "Eraser tool", setTool, 1, ToolbarAlign.LEFT, true, ButtonTypes.IN_A_SET, "toolButtons") as MovieClip;			// top right			setupGUIElement(new Syphon.library.EyeButton, "Download snapshot", WWCommand.SAVE, 1, ToolbarAlign.RIGHT, false);			setupGUIElement(new Syphon.library.HelpButton, "What is all this?", showHelp, 1, ToolbarAlign.RIGHT, false);			setupGUIElement(new Syphon.library.AboutButton, "About Wireworld player", showAbout, 1, ToolbarAlign.RIGHT, false);						// top center			ratioSlider = setupGUIElement(new Syphon.library.RatioSlider, "Adjust Speed", null, 1, ToolbarAlign.CENTER, false) as MovieClip;			ratioSlider.thumb.addEventListener(MouseEvent.MOUSE_DOWN, grabSlider);			ratioSlider.thumb.x = ratioSlider.track.x + (ratioSlider.track.width - ratioSlider.thumb.width);			overdriveButton = setupGUIElement(new Syphon.library.OverdriveButton, "Toggle Overdrive", WWCommand.TOGGLE_OVERDRIVE, 1, ToolbarAlign.CENTER, false, ButtonTypes.TOGGLABLE) as MovieClip;			// bottom left			txtGeneration.defaultTextFormat = textFormat;			txtGeneration.selectable = false;			txtGeneration.height = 22;			setupGUIElement(new Syphon.library.ZoomOutButton, "Zoom out", zoomOut, 2, ToolbarAlign.LEFT, false);			setupGUIElement(new Syphon.library.ResetScaleButton, "Reset view", resetView, 2, ToolbarAlign.LEFT, true);			setupGUIElement(new Syphon.library.ZoomInButton, "Zoom in", zoomIn, 2, ToolbarAlign.LEFT, true);			setupGUIElement(txtGeneration, "Generation", null, 2, ToolbarAlign.LEFT, false);			txtGeneration.y++;						// bottom center			setupGUIElement(loadButton, "Load another Wireworld instance", showLoadPrompt, 2, ToolbarAlign.CENTER, false);			setupGUIElement(fileNameDisplay, "File name", null, 2, ToolbarAlign.CENTER, true);			//setupGUIElement(new Syphon.library.GalleryButton, "View the example gallery", showExampleGallery, 2, ToolbarAlign.CENTER, false);						// bottom right			setupGUIElement(announcerLabel, "Announcer label", null, 2, ToolbarAlign.RIGHT, false);			setupGUIElement(new Syphon.library.AddAnnouncerButton, "Add announcer", placeAnnouncer, 2, ToolbarAlign.RIGHT, true);			txtFPS.defaultTextFormat = rightFormat;			txtFPS.selectable = false;			txtFPS.height = 22;			txtFPS.width = 30;			setupGUIElement(txtFPS, "Frames per second", null, 2, ToolbarAlign.RIGHT, false);			txtFPS.y++;			labelFormat = new TextFormat(null, null, OPAQUE_BACKGROUND_COLOR);			inactiveLabelFormat = new TextFormat(null, null, 0x999999);			announcerLabel.textBox.defaultTextFormat = inactiveLabelFormat;			announcerLabel.textBox.text = defaultLabelText;						// set up the cursors			cursorsByButtonName[handToolButton.name] = handCursor;			toolsByButtonName[handToolButton.name] = "handTool";			toolButtonsByButtonName[handToolButton.name] = handToolButton;			cursorsByButtonName[eraserToolButton.name] = eraserCursor;			toolsByButtonName[eraserToolButton.name] = "eraserTool";			toolButtonsByButtonName[eraserToolButton.name] = eraserToolButton;						cursor = cursorsByButtonName[handToolButton.name];			currentTool = toolsByButtonName[handToolButton.name];						// make changes to the View to reflect these properties of the state			updateSlider(null, _bridge.state.speed);			// reset these properties of the state			_bridge.state.tool = currentTool.charAt(0);			_bridge.state.overdrive = false;			_bridge.state.heatmap = updateHeat; 			_bridge.dispatchEvent(CHANGE_STATE_EVENT);						// set up the hint system			hint.defaultTextFormat = hintFormat;			hint.selectable = false;			hint.autoSize = TextFieldAutoSize.LEFT;			hint.background = true;			hint.backgroundColor = 0xFFFFAA;			hint.border = true;			hint.borderColor = 0x000000;			hint.visible = false;			announcer = null;						font = new Syphon.library.FrucadeMedium as Font;						creditFormat.font = font.fontName;			creditFormat.size = FONT_SIZE;			creditFormat.color = 0xAAAAAA;			creditFormat.leading = 0;						creditBox.defaultTextFormat = creditFormat;			creditBox.width = 300;			creditBox.wordWrap = true;			creditBox.embedFonts = true;						_scene.addChild(grid);			_scene.addChild(paper);			_scene.addChild(toolbar1);			_scene.addChild(toolbar2);			_scene.addChild(resetPrompt);			_scene.addChild(loadPrompt);			disablerIndex = _scene.getChildIndex(loadPrompt);			_scene.addChild(handCursor);			_scene.addChild(eraserCursor);			_scene.addChild(hint);						if (_scene.stage) {				connectToStage();			} else {				_scene.addEventListener(Event.ADDED_TO_STAGE, connectToStage);			}		}				// sets up the stage once it's available		private function connectToStage(event:Event = null):void {			_scene.removeEventListener(Event.ADDED_TO_STAGE, connectToStage);						stage = _scene.stage;						stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.NO_SCALE;						if (Security.sandboxType != "application") {				MacMouseWheel.setup(stage);			}						stage.addEventListener(Event.RESIZE, resize, false, 0, true);			stage.addEventListener(MouseEvent.MOUSE_UP, releaseSlider, false, 0, true);						if (stage.hasOwnProperty("nativeWindow")) {				window = stage["nativeWindow"] as EventDispatcher;				window.addEventListener("resizing", disableCursorDuringResize);			}						resize();			dispatchEvent(READY_EVENT);		}				// The cursors' responses to a mouse up action in the app window.		private function lift(event:MouseEvent):void {			if (event.target is Announcer) {				return;			}			announcerManager.deselectAnnouncers();			announcer = null;			closeCursor();			yell(WWCommand.PAUSE_MOTION, true);			switch (currentTool) {				case "handTool": paper.beginDrag(); _model.refresh(WWRefreshFlag.FULL | WWRefreshFlag.TAIL | _flag); break;				case "eraserTool":				eraseUnderCursor();				stage.addEventListener(MouseEvent.MOUSE_MOVE, eraseUnderCursor, false, 0, true);				break;			}		}				// The cursors' responses to a mouse down action in the app window.		private function drop(event:Event):void {			yell(WWCommand.UNPAUSE_MOTION);			switch (currentTool) {				case "handTool": paper.endDrag(); break;				case "eraserTool": stage.removeEventListener(MouseEvent.MOUSE_MOVE, eraseUnderCursor); break;			}		}				// Methods related to the ratio slider		private function releaseSlider(event:Event):void {			if (draggingSlider) {				updateSlider();				draggingSlider = false;				stage.removeEventListener(MouseEvent.MOUSE_MOVE, updateSlider);			}		}				private function grabSlider(event:Event):void {			draggingSlider = true;			sliderGrip = ratioSlider.thumb.mouseX;			stage.addEventListener(MouseEvent.MOUSE_MOVE, updateSlider, false, 0, true);		}				private function updateSlider(event:Event = null, toRatio:Number = NaN):void {			if (isNaN(toRatio)) {				var min:Number = ratioSlider.track.x;				var max:Number = ratioSlider.track.x + ratioSlider.track.width - ratioSlider.thumb.width;				ratioSlider.thumb.x = FastMath.max(min, FastMath.min(max, ratioSlider.mouseX - sliderGrip));			} else {				toRatio = FastMath.min(1, FastMath.max(0, toRatio));				ratioSlider.thumb.x = toRatio * (ratioSlider.track.width - ratioSlider.thumb.width) + ratioSlider.track.x; 			}						yell(WWCommand.ADJUST_SPEED, getSliderRatio());			_bridge.state.speed = getSliderRatio();			_bridge.dispatchEvent(CHANGE_STATE_EVENT);		}				private function getSliderRatio():Number {			return (ratioSlider.thumb.x - ratioSlider.track.x) / (ratioSlider.track.width - ratioSlider.thumb.width);		}				// cursor updating methods				private function moveCursor(event:MouseEvent):void {			cursor.x = _scene.mouseX;			cursor.y = _scene.mouseY;			event.updateAfterEvent();		}				private function showCursor(event:Event = null):void {			if (cursor.visible || windowResizing) return;			cursor.x = _scene.mouseX;			cursor.y = _scene.mouseY;			cursor.visible = true;			Mouse.hide();		}				private function hideCursor(event:Event = null):void {			cursor.x = cursor.y = -100;			cursor.visible = false;			Mouse.show();		}				private function disableCursorDuringResize(event:Event):void {			stage.addEventListener(MouseEvent.MOUSE_MOVE, enableCursorAfterResize, false, 0, true);			windowResizing = true;			hideCursor();		}				private function enableCursorAfterResize(event:Event):void {			stage.removeEventListener(MouseEvent.MOUSE_MOVE, enableCursorAfterResize);			windowResizing = false;		}				private function closeCursor(event:Event = null):void {			cursor.mouseUpSprite.visible = false;			cursor.mouseDownSprite.visible = true;		}				private function openCursor(event:Event = null):void {			cursor.mouseUpSprite.visible = true;			cursor.mouseDownSprite.visible = false;		}				private function getAnnouncer(event:Event = null):void {			announcer = announcerManager.selectedAnnouncer;		}				// The prompts are little speech bubble dialogs. They		// sprout from the GUI element they're associated with.		private function showResetPrompt(event:Event):void {			resetPrompt.visible = true;		}				private function hideResetPrompt(event:Event):void {			if (event.currentTarget == resetPrompt.yesButton) {				yell(WWCommand.RESET);			}			resetPrompt.visible = false;		}				private function showLoadPrompt(event:Event):void {			loadPrompt.visible = true;		}				private function hideLoadPrompt(event:Event):void {						if (event.currentTarget == loadPrompt.diskButton) {				yell(WWCommand.LOAD_FROM_DISK);			} else if (event.currentTarget == loadPrompt.webButton){				showURLBox();			}						loadPrompt.visible = false;		}				private function showHelp(event:Event = null):void {			_scene.addChildAt(helpBox, disablerIndex);			showDisabler();		}				private function hideHelp(event:Event):void {			if (_scene.contains(helpBox)) _scene.removeChild(helpBox);			hideDisabler();		}				private function showExampleGallery(event:Event = null):void {			_scene.addChildAt(galleryBox, disablerIndex);			showDisabler();		}				private function hideExampleGallery(event:Event):void {			if (_scene.contains(galleryBox)) _scene.removeChild(galleryBox);			hideDisabler();		}				private function showURLBox():void {			_scene.addChildAt(urlBox, disablerIndex);			showDisabler();		}				private function hideURLBox(event:Event):void {			if (_scene.contains(urlBox)) _scene.removeChild(urlBox);			hideDisabler();			if (event.currentTarget == urlBox.loadButton) {				yell(WWCommand.LOAD_FROM_URL, urlBox.textBox.text);			}		}				private function centerBox(__box:DisplayObjectContainer):void {			var bottomChild:DisplayObject = __box.getChildAt(0);			__box.x = stage.stageWidth / 2;			__box.y = stage.stageHeight / 2 - bottomChild.height / 2;		}						// A major player. Throws the GUI element in a toolbar,		// colors it appropriately, sets up hints and click responses,		// and sets up button toggling / radio button logic.		private function setupGUIElement(__element:DisplayObject, __name:String = null, clickFunction:* = null, 				topOrBottom:int = 1, hAlign:Object = null, kiss:Boolean = false, 				type:String = null, setName:String = null, isMainElementInSet:Boolean = false):DisplayObject {						colorizeGUIMovieClip(__element as MovieClip);			__element.opaqueBackground = OPAQUE_BACKGROUND_COLOR;						if (__name) __element.name = "@@@" + __name;			if (clickFunction != null) {				if (clickFunction is Function) {					__element.addEventListener(MouseEvent.CLICK, clickFunction);				} else if (clickFunction is String) {					__element.addEventListener(MouseEvent.CLICK, function(event:Event):void { yell(clickFunction); });				}			}						switch (type) {				case ButtonTypes.TOGGLABLE:					toggleButtons[__element.name] = __element;					toggleButtonStates[__element] = false;					__element.addEventListener(MouseEvent.CLICK, toggle);				break;				case ButtonTypes.IN_A_SET:					if (setName && __element is MovieClip) {						buttonSets[setName] ||= new <MovieClip>[];						buttonSets[setName].push(__element as MovieClip);												(__element as MovieClip).buttonSet = buttonSets[setName];						__element.addEventListener(MouseEvent.CLICK, changeButtonSet);												if (isMainElementInSet) {							changeButtonSet(null, __element as MovieClip);						}					}				break;				case ButtonTypes.NORMAL:				default:				break;			}						(topOrBottom == 1 ? toolbar1 : toolbar2).addGUIElement(__element, hAlign, kiss);						return __element;		}				// Works explicitly on MovieClips. Cry me a river. 		private function colorizeGUIMovieClip(__element:MovieClip):Boolean {			if (!__element) return false;						__element.stop();						// list the element's contents			var child:DisplayObject;			var backChildren:Array = [], frontChildren:Array = [];			var isContainer:Boolean = false;			var isColorizable:Boolean = false;			var isTextDisplay:Boolean = false;						for (var ike:int = 0; ike < __element.numChildren; ike++) {				child = __element.getChildAt(ike);				isColorizable = !colorizeGUIMovieClip(child as MovieClip);				isContainer ||= !isColorizable;				if (isColorizable) {					if (child is Syphon.library.ShapeSeparator) {						__element.removeChild(child);						ike--;					} else if (child is TextField) {						isTextDisplay = true;					} else {						backChildren.push(child);					}				}			}						if (backChildren.length > 1 && !isContainer) frontChildren.push(backChildren.pop());						colorizeList(frontChildren, isTextDisplay ? FRONT_TEXT_CT : FRONT_CT);						if (!(isContainer || isTextDisplay)) {				// drop a hit area around the element				var hitSpot:Sprite = new Sprite();				var hitRect:Rectangle = __element.getBounds(__element);				hitSpot.visible = false;				hitSpot.graphics.beginFill(0x0);				hitSpot.graphics.drawRect(hitRect.x, hitRect.y, hitRect.width, hitRect.height);				hitSpot.graphics.endFill();				__element.addChildAt(hitSpot, 0);				__element.hitArea = hitSpot;				__element.colored = true;				__element.useHandCursor = __element.buttonMode = true;								__element.backChildren = backChildren;				__element.frontChildren = frontChildren;				__element.tapped = false;				elements.push(__element);								__element.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownGUIMovieClip, false, 0, true);				__element.addEventListener(MouseEvent.ROLL_OVER, rollOverGUIMovieClip, false, 0, true);				__element.addEventListener(MouseEvent.ROLL_OUT, rollOutGUIMovieClip, false, 0, true);								__element.mouseChildren = false;			}						colorizeList(backChildren, BACK_MED_CT);						return true;		}				// Methods related to pseudo button events on GUIElements.		private function rollOverGUIMovieClip(event:Event):void {			var element:MovieClip = event.currentTarget as MovieClip;			colorizeList(element.backChildren, element.tapped ? BACK_DARK_CT : BACK_LIGHT_CT);		}				private function mouseDownGUIMovieClip(event:Event):void {			var element:MovieClip = event.currentTarget as MovieClip;			element.tapped = true;			colorizeList(element.backChildren, BACK_DARK_CT);		}				private function mouseUpGUIMovieClip(event:Event):void {			for (var ike:int = 0; ike < elements.length; ike++) {				var element:MovieClip = elements[ike];				if (!element.tapped) continue;				element.tapped = false;				var onElement:Boolean = element.hitTestPoint(_scene.mouseX, _scene.mouseY);				colorizeList(element.backChildren, onElement ? BACK_LIGHT_CT : BACK_MED_CT);			}		}				private function rollOutGUIMovieClip(event:Event):void {			var element:MovieClip = event.currentTarget as MovieClip;			colorizeList(element.backChildren, element.tapped ? BACK_LIGHT_CT : BACK_MED_CT);		}						private function colorizeList(list:Array, ct:ColorTransform):void {			for (var ike:int = 0; ike < list.length; ike++) {				list[ike].transform.colorTransform = ct;			}		}				// drives the appearance of toggling buttons		private function toggle(event:Event):void {			var target:DisplayObject = event.currentTarget as DisplayObject;			if (toggleButtonStates[target] == true) {				target.transform.colorTransform = PLAIN_CT;				toggleButtonStates[target] = false;			} else if (toggleButtonStates[target] == false) {				target.transform.colorTransform = TOGGLED_CT;				toggleButtonStates[target] = true;			}		}				// drives the apperance of radio buttons		private function changeButtonSet(event:Event = null, target:MovieClip = null):void {			if (!event && !target) return;			target ||= event.currentTarget as MovieClip;			var buttonSet:Vector.<MovieClip> = target.buttonSet;			for (var ike:int = 0; ike < buttonSet.length; ike++) {				var currentButton:MovieClip = buttonSet[ike];				if (currentButton == target) {					currentButton.mouseEnabled = false;					currentButton.transform.colorTransform = INVERTED_CT;				} else {					currentButton.mouseEnabled = true;					currentButton.transform.colorTransform = PLAIN_CT;				}			}		}				// Hint methods. The hint timer is reset whenever the mouse is idle.				private function stopHintTimer(event:Event = null):void {			if (hintTimer.running) {				hintTimer.stop();				hideHint();			}		}				private function resetHintTimer(event:Event):void {			if (tooFarX) {				scratch = _scene.mouseX - hint.x - hint.width;			} else {				scratch = _scene.mouseX - hint.x;			}						if (tooFarY) {				scratch2 = _scene.mouseY - hint.y;			} else {				scratch2 = _scene.mouseY - hint.y - 25 - hint.height;			}						if (Math.sqrt(scratch * scratch + scratch2 * scratch2) > 30 || !hint.visible) {				hideHint();				hintTimer.reset();				hintTimer.start();			} else {				positionHint();			}		}				private function showHint(event:TimerEvent = null):void {						var targetVector:Vector.<DisplayObject>;						if (!hint.visible) {								mousePoint.x = _scene.mouseX, mousePoint.y = _scene.mouseY;				targetVector = Vector.<DisplayObject>(_scene.getObjectsUnderPoint(mousePoint));				target = targetVector[targetVector.length - 1];				if (target && target != toolbar1 && target != toolbar2) {					// ascend the target's display lineage to the relevant parent					while (!((target is MovieClip && (target as MovieClip).colored) || 							(target is TextField && target.parent == _scene) || 							target == announcerLabel || target == fileNameDisplay || target == ratioSlider || 							target.parent == aboutBox || target is Stage)) {						target = target.parent;					}					if (target.parent == aboutBox) {						hint.text = ":-)";						hint.visible = true;					} else if (!(target is Stage || target.parent == aboutBox) && target.name.indexOf("@@@") == 0) {						hint.text = target.name.substr(target.name.indexOf("@@@") + 3);						hint.visible = true;					}				}				if (hint.visible) {					positionHint();				}			}		}				private function hideHint(event:TimerEvent = null):void {			if (hint.visible) {				hint.visible = false;			}		}				private function positionHint():void {			hint.x = _scene.mouseX;			if (hint.x + hint.width > stage.stageWidth) {				hint.x = _scene.mouseX - hint.width;				tooFarX = true;			} else {				tooFarX = false;			}			hint.y = _scene.mouseY + 15;			if (hint.y + hint.height > stage.stageHeight) {				hint.y = _scene.mouseY - 10 - hint.height;				tooFarY = true;			} else {				tooFarY = false;			}		}				// Renames the current announcer with the name in the announcerLabel field.		private function announcerLabelHandler(event:TextEvent):void {			_announcer.name = announcerLabel.textBox.text + event.text;		}				private function clearAnnouncerLabel(event:Event):void {			announcer = null;		}				private function updateFlag():void {			_flag = 0;			if (updateHeat) _flag |= WWRefreshFlag.HEAT;		}				// Turns on and off heat vision.		private function toggleHeat(event:Event):void {			paper.toggleHeat();			updateHeat = !updateHeat;			updateFlag(); 			_bridge.state.heatmap = updateHeat;			_bridge.dispatchEvent(CHANGE_STATE_EVENT);		}				private function setTool(event:Event):void {			currentTool = toolsByButtonName[(event.currentTarget as DisplayObject).name];			_bridge.state.tool = currentTool.charAt(0);			_bridge.dispatchEvent(CHANGE_STATE_EVENT);			cursor.x = cursor.y = -100;			cursor.visible = false;			cursor = cursorsByButtonName[(event.currentTarget as DisplayObject).name];			cursor.x = _scene.mouseX, cursor.y = _scene.mouseY;		}				private function eraseUnderCursor(event:Event = null):void {			_model.eraseRect(eraserCursor.getBounds(paper));			_model.refresh(_flag | WWRefreshFlag.TAIL);		}				private function updateAlertProgress(event:Event = null):void {			alertProgressMat.tx += 5;			alertProgressIndicator.graphics.clear();			alertProgressIndicator.graphics.beginBitmapFill(alertProgressStripe, alertProgressMat, true);			alertProgressIndicator.graphics.drawRect(0, 0, alertBox.width, 25);			alertProgressIndicator.graphics.endFill();		}				private function yell(type:String, value:* = null):void {			if (_callback != null) _callback(type, value);			//dispatchEvent(new WWEvent(type, value));		}				private function yellPause(event:Event = null):void {			yell(WWCommand.PAUSE_MOTION);		}				private function changeActiveStatus(event:Event):void {			yell(event.type);		}				private function buildAPI():void {						function api_loadFromDisk():void { yell(WWCommand.LOAD_FROM_DISK); }			function api_loadFromWeb():void { showURLBox(); }						function api_toggleOverdrive():void {				overdriveButton.dispatchEvent(CLICK_EVENT);				_bridge.state.overdrive = _bridge.state.overdrive ? false : true;				_bridge.dispatchEvent(CHANGE_STATE_EVENT);			}						function api_adjustSpeed(amount:Number):void {				updateSlider(null, getSliderRatio() + amount);			}						function api_changeTool(tool:String):void {				for (var prop:String in toolButtonsByButtonName) {					if (prop.charAt(3).toLowerCase() == tool.charAt(0).toLowerCase()) {						toolButtonsByButtonName[prop].dispatchEvent(CLICK_EVENT);						break;					}				}			}						function api_togglePlayPause():void { yell(WWCommand.TOGGLE_PLAY_PAUSE); }			function api_reset():void { yell(WWCommand.RESET); }			function api_step():void { yell(WWCommand.STEP); }			function api_adjustZoom(amount:int):void { (amount < 0) ? zoomOut() : zoomIn(); }			function api_resetView():void { resetView(); }			function api_toggleHeatMap():void { heatButton.dispatchEvent(CLICK_EVENT); }			function api_showHelp():void { showHelp(); }			function api_showAbout():void { showAbout(); }			function api_dispose():void { trace("DISSOLVE", dissolve(_scene)); }				_bridge.loadFromDisk = api_loadFromDisk;			_bridge.loadFromWeb = api_loadFromWeb;			_bridge.toggleOverdrive = api_toggleOverdrive;			_bridge.adjustSpeed = api_adjustSpeed;			_bridge.changeTool = api_changeTool;			_bridge.togglePlayPause = api_togglePlayPause;			_bridge.reset = api_reset;			_bridge.step = api_step;			_bridge.adjustZoom = api_adjustZoom;			_bridge.resetView = api_resetView;			_bridge.toggleHeatMap = api_toggleHeatMap;			_bridge.showHelp = api_showHelp;			_bridge.showAbout = api_showAbout;			_bridge.dispose = api_dispose;		}				private function dissolve(container:DisplayObjectContainer):int {			var total:int = 0;			if (!container) return 0;			while (container.numChildren) {				total += 1 + dissolve(container.removeChildAt(0) as DisplayObjectContainer);			}			return total;		}	}}internal class ButtonTypes {	public static const NORMAL:String = "normal";	public static const TOGGLABLE:String = "togglable";	public static const IN_A_SET:String = "inASet";}